## krush

**krush** is a lightweight persistence layer for Kotlin based on Exposed SQL DSL. It’s similar to requery and micronaut-data jdbc, but designed to work idiomatically with Kotlin and immutable data classes.

It’s based on compile-time JPA annotation processor that generates Exposed DSL table and objects mappings for you. This lets you instantly start writing type-safe SQL queries without need to write boilerplate infrastructure code.

Rationale
* **(type-safe) SQL-first** - use type-safe SQL-like DSL in your queries, no string or method name parsing 
* **Minimal changes to your domain model** - no need to extend external interfaces and used special types - just add annotations to your existing domain model
* **Explicit fetching** - you specify explicitly in query what data you want to fetch, no additional fetching after data is loader
* **No runtime magic** - no proxies, lazy loading, just data classes containing data fetched from DB
* **Pragmatic** - easy to start, but powerful even in not trivial cases (associations, grouping queries)

### Example
Given a simple `Book` class:

```kotlin
data class Book(
   val id: Long? = null,
   val isbn: String,
   val title: String,
   val author: String,
   val publishDate: LocalDate
)
```

we can turn it into krush entity by adding @Entity and @Id annotations:

```kotlin
@Entity
data class Book(
   @Id @GeneratedValue
   val id: Long? = null,
   val isbn: String,
   val title: String,
   val author: String,
   val publishDate: LocalDate
)
```

When we build the project we’ll have BookTable mapping generated for us. So we can persist the Book:

```kotlin
val book = Book(
   isbn = "1449373321", publishDate = LocalDate.of(2017, Month.APRIL, 11),
   title = "Designing Data-Intensive Applications", author = "Martin Kleppmann"
)

val persistedBook = BookTable.insert(book)
assertThat(persistedBook.id).isNotNull()
```

So we have now a `Book` persisted in DB with autogenerated `Book.id` field.
And now we can use type-safe SQL DSL to query the BookTable:

```kotlin
val selectedBooks = (BookTable)
   .select { BookTable.author like "Martin K%" }
   .toBookList()

// then
assertThat(selectedBooks).containsOnly(persistedBook)
```
